#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var plurals = _interopDefault(require('cldr-core/supplemental/plurals.json'));
var ordinals = _interopDefault(require('cldr-core/supplemental/ordinals.json'));

/**
 * messageformat 0.0.1 – i18n message formating, all inclusive
 * Made with ♫·♪ & -♥- by Adrien Gibrat <adrien.gibrat@gmail.com>
 * Published under (WTFPL OR MIT) License
 */

// map object, optionally by given order
function map (mapper, object, order) {
	return Object.keys(object)
		.sort(order || (function () { return 0; }))
		.map(function (key) { return mapper(object[key], key); })
}

// reduce object, fp style
function reduce (reducer, initial, object) {
	return Object.keys(object).reduce(function (acc, key) { return reducer(acc, object[key], key); }, initial)
}

// pick keys in given object
function pick (keys, object) { 
	return Object.keys(object)
		.filter(function (key) { return -1 !== keys.indexOf(key) })
		.reduce(function (pick, key) { return pick[key] = object[key], pick }, {})
}

// create object comparator to sort by prop, according given order hash
function by (prop, order) {
	return function (a, b) { return order[a[prop]] < order[b[prop]] ? -1 : 1; }
}

// generate variable names: 'a', 'b', ..., 'z', 'a1', 'b2', etc.
function variable (index) {
	return String.fromCharCode(index % 26 + 97)+ (index / 26 | 0 || '')
}

// KISS helper
function identity (a) { return a }

// DRY helper
function prop (key) { return function (object) { return object[key]; } }

// cleanup source code generated by new Function
function clean (source) {
	return String(source)
		.replace(/(\bfunction )(anonymous)?/g, '$1')
		.replace(/\s*\/\*\*\//g, '')
}

// small UMD loader
var loader = function (root, name, factory) {
	/* global define: false, exports: false, module: false */
	if ('function' === typeof define && define.amd)
		define(name, factory())
	else if ('object' === typeof exports)
		module.exports = factory()
	else
		root[name] = factory()
}

// format source with UMD loader
function umd (name, factory) {
	return clean(("(" + loader + ")(this, \"" + name + "\", " + factory + ");"))
}

// dedupe plural fn definitions and types
function dedupe (dedupe, fn, locale) {
	var fns = dedupe.fns
	fns[fn] = { locales: fns[fn] ? fns[fn].locales.concat(locale) : [locale], fn: fn }
	dedupe.types[fn.types] = { list: fn.types }
	return dedupe
}

// make source parts from deduped fn definitions and types
function make (source, dedupe) {
	var types = this[dedupe.fn.types]
	var name = variable(source.refs.length)
	source.refs.push((name + " = " + (dedupe.fn)))
	if (!types.name) {
		types.name = variable(source.refs.length)
		source.refs.push(((types.name) + " = " + (JSON.stringify(types.list))))
	}
	source.types.push(("types(" + name + ", " + (types.name) + ")"))
	dedupe.locales.forEach(function (locale) { return source.props.push(("\"" + locale + "\": " + name)); })
	return source
}

// compile factory of locales plural hash
function factory () {
	var dedupes = reduce(dedupe, {fns: {}, types: {}}, this)
	var sources = reduce(make.bind(dedupes.types), {refs: [], types: [], props: []}, dedupes.fns)
	var LF = '\n'
	var COMMA = ', '
	return new Function('', [
		'var ' + sources.refs.join(COMMA)
		, 'function types (fn, types) { fn.types = types.slice() }'
		, sources.types.join(LF)
		, 'return {' + sources.props.join(COMMA) + '}'
	].join(LF))
}

// locales batch rules parser
function builder (compiler) { return function (dictionary) { return reduce(function (locales, rules, locale) {
		try { locales[locale] = compiler(rules) }
		catch (error) { throw Error(("compile " + locale + " plural failed (" + (error.message) + ")")) }
		return locales
	}, Object.create({factory: factory}), dictionary); }; }

Vars.prototype = {
	// generate var declarations block
	toString: function toString () {
		var declarations = map(identity, this.declarations, this.sort)
		return declarations.length ? 'var ' + declarations.join('\n\t, ') + '\n' : ''
	}
	// parse source to find given operands (variable names)
	, parse: function parse (source) {
		var this$1 = this;

		this.lookups.forEach(function (lookup) { return lookup.call(this$1, source); })
		return this
	}
}

// helps tracking variables used in source code
function Vars (operands, sort) {
	this.declarations = {}
	this.lookups = (operands || [])
		// create operand lookup function used to parse source
		.map(function (operand) {
			var name = /^\w+/.exec(operand).pop()
			var pattern = new RegExp('\\b' + name + '\\b')
			return function (source) {
				if (pattern.test(this + source))
					this.declarations[name] = operand
			}
		})
		// reverse for dependencies
		.reverse()
	this.sort = sort
}

// build rule definition object
function parse (vars, rule, name) {
	var parts = rule.trim().split(/\s*@\w*/)
	var type = name.replace('pluralRule-count-', '')
	var AND = ' && ', OR = ' || ', EQ = ' == ', INT = 'j && '
	// shamelessly borrowed from https://github.com/eemeli/make-plural.js
	var condition = parts.shift()
		.replace(/([fin]) % (\d+)/g, function (_, x, n) { // modulos
			var name = x + n
			vars.declarations[name] = name + " = " + ('n' === x ? 'i' : x) + " % " + n
			return ("" + ('n' === x ? INT : '') + name)
		})
		.replace(/(\w+ (!?)= )([0-9.]+,[0-9.,]+)/g, function (_, expr, not, list) { return ("(" + expr + (list.split(',').join((not ? AND : OR) + expr)) + ")"); }
		)
		.replace(/(\w+) (!?)= ([0-9]+)\.\.([0-9]+)/g, function (_, x, not, a, b) { return not ?
				("(" + x + " < " + a + OR + x + " > " + b + ")")
				: ("" + ('n' === x ? INT : '') + x + " >= " + a + AND + x + " <= " + b); }
		)
		.replace(/ and /g, AND)
		.replace(/ or /g, OR)
		.replace(/ = /g, EQ)

	return {
		source: ((condition ? 'if (' + condition + ')' : '') + "return \"" + type + "\"")
		, type: type
		, test: parts.join(' ').split(/[ ,~…]+/).filter(Boolean)
	}
}

// test if function returns as expected for given values
function test (fn, expected, values) {
	values.forEach(function (n) {
		var result = fn(n)
		if (result != expected)
			throw Error(("n = " + n + " -> " + result + ", expected " + expected))
	})
}

function compiler (ruleset) {
	var vars = new Vars([
		'b = (n + ".").split(".")' // array, integer digits & fractional digits in n
		, 'f = b[1]' // string, fractional digits in n
		, 'i = b[0]' // string, integer digits of n
		, 'j = Number(i) == n' // boolean, n is an integer
		, 't = f.replace(/0+$/, "")' // string, fractional digits in n without trailing zeros
		, 'v = f.length' // integer, number of fraction digits in n
	], function (a, b) { return a.length - b.length || (a < b ? -1 : 1); }) // sort variable names
	var rules = map(parse.bind(null, vars), ruleset)
		.sort(by('type', {zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5}))
	var body = rules.map(prop('source')).join('\n')
	var fn = new Function('n', '\t' + (vars.parse(body) + body).replace(/\n/g, '\n\t'))
	fn.types = rules.map(prop('type'))
	rules.forEach(function (rule) { return test(fn, rule.type, rule.test); })
	return fn
}

var args = process.argv.slice(2)
var plural = {
	plural: plurals.supplemental['plurals-type-cardinal']
	, ordinal :ordinals.supplemental['plurals-type-ordinal']
}

Object.keys(plural)
	.forEach(function (name) {
		var subset = args.length ? pick.bind(null, args) : identity
		var compile = builder(compiler)
		var plurals = compile(subset(plural[name]))
		// eslint-disable-next-line no-console
		console.log(umd(name, plurals.factory()))
	})